#!/usr/bin/env python3

# Standard library imports
import argparse
import base64
import re
import hmac
import datetime
import time
import struct
from urllib.parse import quote
from hashlib import sha1

# Third party imports
from qrcode import make

def gen_qr(issuer: str, account: str, secret: str) -> None:
    """This command should generate a jpg picture or svg picture 
    of the QR code that encodes the URI GA expects. URI contains 
    secret keys along with the user id required for the TOTP algorithm.
    """ 

    # sanitize issuer
    issuer = quote(issuer)

    # verify email
    match = re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', account)
    if match == None:
        print('invalid email address')
        exit(1)
        
    # check secret key
    if secret == None or len(secret) == 0:
       print('secret cannot be blank')
       exit(1)

    # encode secret
    string_to_encode = secret.encode('ascii')
    encoded = base64.b32encode(string_to_encode)

    path_params = {'issuer': issuer, 'secret': encoded.decode('ascii'), 'account': account} 
    path = "otpauth://totp/{issuer}:{account}"\
    "?secret={secret}"\
    "&issuer={issuer}"\
    "&algorithm=SHA1"\
    "&digits=6"\
    "&period=30".format(**path_params)

    img = make(path)
    img.save("mccabmic_qr.png")

def timecode(for_time: datetime, interval:int=30) -> int:
    """This converts the given datetime object into an integer divided by the interval
    note: interval is defaulted at 30.
    """

    i = time.mktime(for_time.timetuple())
    return int(i / interval)

def int_to_bytes(x: int) -> bytes:
    """return a bytearray object from an integer"""
    return struct.pack(">Q", x)   

def get_otp(secret: str) -> str:
    """This command should generate an OTP
    which must match the OTP generated by the Google Authenticator for that 30
    second period and print it to the screen. Optionally, you can make the program
    run such that it prints the OTP and then sleeps for 30 seconds and then again
    prints another OTP and keeps on going forever.
    """

    encoded_key_bytes = secret.encode('ascii')
    saved_time = datetime.datetime.now()
    saved_time_integer = timecode(saved_time)

    hashed = hmac.new(encoded_key_bytes, int_to_bytes(saved_time_integer), sha1)
    hasher = bytearray(hashed.digest())
    
    # last element
    offset = hasher[-1] & 0xf

    binary = ((hasher[offset] & 0x7f) << 24 |
                (hasher[offset + 1] & 0xff) << 16 |
                (hasher[offset + 2] & 0xff) << 8 |
                (hasher[offset + 3] & 0xff))

    code = str( binary % 1000000 )
    while (len(code) < 6):
        code = '0' + code
    return code


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--generate-qr", help="generate a "
        "jpg picture or svg picture of the QR code that encodes the URI GA expects",
        action='store_true'
        )

    group.add_argument(
        "--get-otp", help="generate an "
        "OTP which must match the OTP generated by the Google Authenticator "
        "for that 30 second period and print it to the screen",
        action='store_true'
        )
    
    args = parser.parse_args()

    if args.generate_qr:
        print("creating QR with the following info: issuer=\"Auri Smells\", secret=\"cat\", account=\"fake@gmail.com\"")
        gen_qr(issuer="Auri Smells", secret="cat", account="fake@gmail.com")

    else:
        print("creating OTP with the following info: secret=\"cat\"")
        code = get_otp(secret="cat")
        print(code)    
